#!/usr/bin/env python
# -*- coding: utf-8 -*-

import ConfigParser
import os
import platform
import pyperclip
import qiniu
import signal
import sys
import threading
import time
import urllib
from mimetypes import MimeTypes
from os.path import expanduser

from watchdog.events import PatternMatchingEventHandler
from watchdog.observers import Observer


# 使用watchdog 监控文件夹中的图像
class MyHandler(PatternMatchingEventHandler):
    ignore_directories = True
    case_sensitive = False

    def process(self, event):
        if event.event_type == 'created' or event.event_type == 'modified':  # 如果是新增文件或修改的文件
            myThread(event.src_path, 1).start()  # 开启线程

    def on_modified(self, event):
        self.process(event)

    def on_created(self, event):
        self.process(event)


# 使用多线程上传
class myThread(threading.Thread):
    def __init__(self, filePath, mode):  # filePath 文件路径 和 上传模式
        threading.Thread.__init__(self)
        self.filePath = filePath
        self.mode = mode

    def run(self):
        threadLock.acquire()
        job(self.filePath, self.mode)
        threadLock.release()


# 上传图像、复制到粘贴板、写到文件
def job(file, mode):
    if mode == 1:
        url = upload_with_full_Path(file)
    if mode == 2:
        url = upload_with_full_Path_cmd(file)
    pyperclip.copy(url)
    pyperclip.paste()
    print url


# -----------------配置--------------------
homedir = expanduser("~")  # 获取用户主目录
config = ConfigParser.RawConfigParser()
config.read(homedir + '/.qiniu.cfg')  # 读取配置文件


mime = MimeTypes()
threadLock = threading.Lock()


# 优雅退出
def exit_gracefully(signum, frame):
    signal.signal(signal.SIGINT, original_sigint)
    try:
        if raw_input("\nReally quit? (y/n)> ").lower().startswith('y'):
            sys.exit(1)
    except KeyboardInterrupt:
        print("Ok ok, quitting")
        sys.exit(1)
    signal.signal(signal.SIGINT, exit_gracefully)


original_sigint = signal.getsignal(signal.SIGINT)
signal.signal(signal.SIGINT, exit_gracefully)

try:
    bucket = config.get('config', 'bucket')  # 设置  bucket
    accessKey = config.get('config', 'accessKey')  # 设置  accessKey
    secretKey = config.get('config', 'secretKey')  # 设置  secretKey
    path_to_watch = config.get('config', 'path_to_watch')  # 设置   监控文件夹
    enable = config.get('custom_url', 'enable')  # 设置自定义使能 custom_url
    if enable == 'false':
        print 'custom_url not set'
    else:
        addr = config.get('custom_url', 'addr')
except ConfigParser.NoSectionError, err:
    print 'Error Config File:', err


# 设置编码
def setCodeingByOS():
    return 'utf-8'


# 处理七牛返回结果
def parseRet(ret_data, resp_info):
    if ret_data is not None:
        for k, v in ret_data.items():
            if k[:2] == "x:":
                print(k + ":" + v)
        for k, v in ret_data.items():
            if k[:2] == "x:" or k == "hash" or k == "key":
                continue
            else:
                print(k + ":" + str(v))
    else:
        print("Upload file failed!")


# 上传文件方式 1
def upload_without_key(bucket, filePath, uploadname):
    auth = qiniu.Auth(accessKey, secretKey)
    up_token = auth.upload_token(bucket, key=None)
    key = uploadname
    retData, respInfo = qiniu.put_file(up_token, key, filePath, mime_type=mime.guess_type(filePath)[0])
    parseRet(retData, respInfo)


# 上传文件方式 2
def upload_with_full_Path(filePath):

    fileName = "".join(filePath.rsplit(path_to_watch))[1:]
    upload_without_key(bucket, filePath, fileName.decode(setCodeingByOS()))
    if enable == 'true':
        return addr + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))
    else:
        return 'http://' + bucket + '.qiniudn.com/' + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))


# 上传文件方式 3
def upload_with_full_Path_cmd(filePath):

    fileName = os.path.basename(filePath)
    upload_without_key(bucket, filePath, fileName.decode(setCodeingByOS()))
    if enable == 'true':
        return addr + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))
    else:
        return 'http://' + bucket + '.qiniudn.com/' + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))


def unix_main():
    if len(sys.argv) > 1:
        for i in sys.argv[1:]:
            myThread(i, 2).start()
        sys.exit(-1)
    print "running ... ... \nPress Ctr+C to Stop"
    observer = Observer()
    observer.schedule(MyHandler(), path=path_to_watch if path_to_watch else '.', recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


def main():
    if os.name == 'nt' or platform.system() == 'Windows':
        print '不支持'
        exit()
    else:
        unix_main()


if __name__ == "__main__":
    main()
